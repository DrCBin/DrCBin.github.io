---
title: 僵尸进程和孤儿进程
category: c/c++
excerpt: |
  僵尸进程和孤儿进程的产生和防范
---

linux系统下，可以由一个进程fork产生另一个进程，这就有了一些可能.其中`一个进程`叫做父进程，`另一个进程`叫做子进程。

## 孤儿进程和僵尸进程

- 大家都知道，死了父母的孩子叫孤儿，同样，父线程如果死了，但子进程还在，那么这个进程就叫做孤儿进程。**孤儿进程的父进程的pid会被重置为1**.
 
- 而如果孩子提前走到生命的尽头，父亲却还健在，此时父亲就需要料理死去孩子的后世，安葬，清理孩子的遗物，万一孩子留了一大笔钱呢。但是如果孩子死了，父亲却不管不问，那么孩子就会变成僵尸.

- 在进程状态中，一个进程结束了自己的任务之后，是先进入`退出状态`,也就是才结束生命。然后等着父亲进程来处理一下后事，才进入`终止状态`，也就是正式走完一生。

- 退出状态存在的意义: 子进程退出后，还保留着它的一些状态信息，比如pid，占用内存，生存时间，cup使用等，可能父进程某些时候需要查看.

- 但是一个进程如果中途出了异常，那么它会直接进入`终止状态`.

- 如果子线程执行玩业务逻辑，进入退出状态，而且父进程还在，但父进程却对他不管不问，那么这个子进程就一直保持在退出状态，而不会进入终止状态，此时这个子线程就叫做僵尸进程.

#### 总结一下:

孤儿进程:父进程挂了的进程叫孤儿进程。

僵尸进程: 它的父进程还在，却即使该进程已经执行完，它父亲也不管它的进程，叫僵尸进程。


## 孤儿进程和僵尸进程对系统的影响

- 由于孩子进程退出后还保留这进程的一些状态，也就是保留着退出状态的一些东西，所以它还会保留着进程，也就是还能查到这个进程.改进程还证据着一定的资源。

- 如果死掉的孩子越来越多就会浪费一些系统资源，如果量非常大，那么系统崩溃啥的也不是问题

## 系统对孤儿进程和僵尸进程的处理

- 当系统启动的时候，会创建第一个用户进程，叫做[init进程](http://baike.baidu.com/item/init%E8%BF%9B%E7%A8%8B)。

- 对于孤儿进程，init进程会对他们进行关心，他们死后，会将他们妥善处理，是他们能从`退出状态`进入`终止状态`,完整的走完这一生。

- 对于僵尸进程，由于它父亲还在，所以init进程没有权利去管他们。

#### 总结

对于孤儿进程，init进程会清理他们，所以他们对系统不会造成影响。

对于僵尸进程，由于它们的父亲还在，所以系统不会管他们，所以庞大数量的僵尸进程会影响系统稳定。

## 对已经存在的僵尸进程的处理

杀了他们的父亲，让他们变成孤儿，这样init就有权利来处理他们了。

## 防止僵尸进程产生的方法
- 使用wait来等待子进程结束并回收资源，[wait](http://single-thread.me/c/c++/2017/05/02/wait-and-waitpid/)用法:

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/wait.h>
int main(){
	if(fork() > 0){
		// 表示是父进程
		pid_t childPid = wait(); //获取结束的子进程的pid
	}
	else{
		// do something
	}
	return 0;
}

```

上述方法可以预防僵尸进程的出现,但这个方法有一些弊端:

   - 弊端:
       - wait()只等待一个子进程返回就继续往下走了。如果一个父进程产生了多个子进程，就不能使用一个wait保证所有的子进程都结束。
       - wai()需要等待子进程结束，如果子进程执行的时间过程，则会过分影响到父进程的执行.
       
- 使用[waitpid()](http://single-thread.me/c/c++/2017/05/02/wait-and-waitpid/):
代码示例：同上wait()代码示例，将wait()改为waitpid(),并按徐传递参数即可.

- 使用信号:每当子进程结束，内核都会给其父进程发送信号，但是父进程对这个信号默认不做任何处理，所以我们可以通过这个信号来做一些事情，我们要做的是就是当收到内核的信号时，表示我们有子进程结束了，此时该去处理了。

```c
void handle(int signo){
	// 我也是看的网上例子，知道这是一个处理子进程后续的函数，具体怎么定义，这个参数是干啥用的等我一概不知，现在也没打算深入，后续用到了再深入
	int status;
	if(wait(&status) < 0){
		perror("wait:");
	}

int main(){
	signal(SIGCHLD, &handle); //绑定接到信号的处理函数
	// do something
	fork();  //正常的调用fork执行业务逻辑
	// do something
	return 0;
}
```